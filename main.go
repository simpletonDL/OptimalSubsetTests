package main

func main() {

	/*tree := Tree{Root:NewNode(0,0,0)}
	tree.Root.AddChild(NewNode(0,0,1))
	tree.Root.Children[0].AddChild(NewNode(0,0,2))
	tree.Root.Children[0].AddChild(NewNode(0,0,3))
	tree.Root.Children[0].AddChild(NewNode(0,0,4))
	tree.Root.Children[0].Children[2].AddChild(NewNode(0,0,7))
	tree.Root.Children[0].Children[0].AddChild(NewNode(0,0,8))
	tree.Root.Children[0].Children[0].AddChild(NewNode(0,0,9))
	tree.Root.AddChild(NewNode(0,0,5))
	tree.Root.Children[1].AddChild(NewNode(0,0,6))
	tree.UpdateSizes()
	knapsack.SortChildren(tree)
	tree.Print()*/

	/*tree := Tree{Root:NewNode(0,0,0)}
	tree.Root.AddChild(NewNode(0,0,1))
	tree.Root.AddChild(NewNode(0,0,2))
	tree.Root.Children[1].AddChild(NewNode(0,0,3))
	tree.Root.Children[1].AddChild(NewNode(0,0,4))
	tree.Root.Children[1].Children[1].AddChild(NewNode(0,0,5))
	tree.Root.Children[1].Children[1].AddChild(NewNode(0,0,6))
	tree.Root.Children[1].Children[1].Children[1].AddChild(NewNode(0,0,7))
	tree.Root.Children[1].Children[1].Children[1].AddChild(NewNode(0,0,8))
	tree.Root.Children[1].Children[1].Children[1].AddChild(NewNode(0,0,9))
	tree.Root.Children[1].Children[1].Children[1].AddChild(NewNode(0,0,10))
	tree.Root.Children[1].Children[1].Children[1].AddChild(NewNode(0,0,11))
	tree.Root.Children[1].Children[1].Children[1].AddChild(NewNode(234,0,12))
	tree.Root.Children[1].Children[1].Children[1].AddChild(NewNode(0,0,13))
	tree.Root.Children[1].Children[1].Children[1].AddChild(NewNode(0,0,14))
	tree.Root.Children[1].Children[1].Children[1].AddChild(NewNode(0,0,15))
	tree.Root.Children[1].Children[1].Children[1].AddChild(NewNode(0,0,16))
	tree.Root.Children[1].Children[1].Children[1].AddChild(NewNode(0,0,17))
	tree.Root.Children[1].Children[1].Children[1].AddChild(NewNode(0,0,18))
	tree.UpdateSizes()*/

	/*tree1, tree2, split := SplitTree(tree)
	tree1.Print()
	fmt.Println()
	tree2.Print()
	fmt.Println()
	fmt.Println(split.ID)*/

	/*tree := Tree{Root:NewNode(0,0,0)}
	tree.Root.AddChild(NewNode(0,0,1))
	tree.Root.AddChild(NewNode(0,0,2))
	tree.UpdateSizes()
	tree1, tree2, split := SplitTree(tree)
	tree1.Print()
	fmt.Println()
	tree2.Print()
	fmt.Println()
	fmt.Println(split.ID)*/

	/*tree.Root.Children[1].SetRequired()
	answer := FindOptimalProbability(tree, 10)
	fmt.Println(answer)*/

	/*tree := tests.GenerateTree(4, 10, 10)
	fmt.Println(knapsack.FindOptimalProbability(tree, 10)[10])
	fmt.Print(knapsack.FindOptimalSubset(tree, 10))*/
}